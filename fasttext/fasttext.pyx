# fastText C++ interface
from interface cimport FastTextModel

# Cython
from libcpp.string cimport string
from libcpp.vector cimport vector

# Python module
import os
from builtins import bytes
from model import WordVectorModel
from model import SupervisedModel
from model import SupervisedTestResult as TestResult

# This Python class wrap the C++ class FastText from interface.pxd
# so it can be accessed via Python
# http://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html
cdef class FastTextWrapper:
    cdef FastTextModel fm

    def __cinit__(self):
        self.fm = FastTextModel()
    
    def load_model(self, filename):
        self.fm.loadModel(filename)    

    @property
    def minCount(self):
        return self.fm.minCount

    @property
    def wordNgrams(self):
        return self.fm.wordNgrams

    @property
    def bucket(self):
        return self.fm.bucket

    @property
    def minn(self):
        return self.fm.minn

    @property
    def maxn(self):
        return self.fm.maxn

    @property
    def t(self):
        return self.fm.t

    @property
    def lrUpdateRate(self):
        return self.fm.lrUpdateRate

    @property
    def dim(self):
        return self.fm.dim

    @property
    def ws(self):
        return self.fm.ws

    @property
    def epoch(self):
        return self.fm.epoch

    @property
    def neg(self):
        return self.fm.neg

    @property
    def lossName(self):
        return self.fm.lossName

    @property
    def modelName(self):
        return self.fm.modelName

    def dict_nwords(self):
        return self.fm.dictGetNWords()   

    def dict_get_word(self, i, encoding):
        cdef string cpp_string
        cpp_string = self.fm.dictGetWord(i)
        return cpp_string.decode(encoding)

    def dict_nlabels(self):
        return self.fm.dictGetNLabels()   

    def dict_get_label(self, i, encoding):
        cdef string cpp_string
        cpp_string = self.fm.dictGetLabel(i)
        return cpp_string.decode(encoding)

    def get_vector(self, word, encoding):
        word_bytes = bytes(word, encoding)
        return self.fm.getVectorWrapper(word_bytes)

    def predict(self, text, k, label_prefix, encoding):
        cdef vector[string] raw_labels
        text_bytes = bytes(text, encoding)
        labels = []
        raw_labels = self.fm.predict(text_bytes, k)
        for raw_label in raw_labels:
            label = raw_label.decode(encoding)
            label = label.replace(label_prefix, '')
            labels.append(label)
        return labels

    def predict_prob(self, text, k, label_prefix, encoding):
        cdef vector[vector[string]] raw_results
        cdef string cpp_str
        text_bytes = bytes(text, encoding)
        labels = []
        probabilities = []
        raw_results = self.fm.predictProb(text_bytes, k)
        for result in raw_results:
            cpp_str = result[0]
            label = cpp_str.decode(encoding)
            label = label.replace(label_prefix, '')
            cpp_str = result[1]
            prob = float(cpp_str)
            labels.append(label)
            probabilities.append(prob)
        return list(zip(labels, probabilities))

    def test(self, test_file, k, encoding):
        test_file = bytes(test_file, encoding)
        cpp_str = self.fm.test(test_file, k)
        test_result = cpp_str.decode(encoding)
        results = test_result.split('\n')
        nexamples = int(results[0].split()[1].strip())
        precision = float(results[1].split()[1].strip())
        recall = float(results[2].split()[1].strip())
        return TestResult(precision, recall, nexamples)

# Read .bin file that generated by fasttext(1) and import the data
# as the Python object.
# * label_prefix is an optional argument.
#   prefix will be removed from the label name and stored in the model.labels
def load_model(filename, label_prefix='', encoding='utf-8'):
    # Check if the filename is readable
    if not os.path.isfile(filename):
        raise ValueError('fastText: trained model cannot be opened!')

    # Initialize the model first
    model = FastTextWrapper()
    # We convert the python string to C++ string
    filename_bytes = bytes(filename, encoding)
    
    try:
        # Load the model
        model.load_model(filename_bytes)
    except Exception as err:
        raise Exception('fastText: Cannot load ' + filename +
                ' due to ' + str(err))

    model_name = model.fm.modelName
    if model_name == 'skipgram' or model_name == 'cbow':
        words = []
        # We build the dictionary here to support unicode characters
        for i in xrange(model.dict_nwords()):
            word = model.dict_get_word(i, encoding)
            words.append(word)
        return WordVectorModel(model, words, encoding)
    elif model_name == 'supervised':
        labels = []
        for i in xrange(model.dict_nlabels()):
            label = model.dict_get_label(i, encoding)
            # Remove the prefix
            labels.append(label.replace(label_prefix, ''))
        return SupervisedModel(model, labels, label_prefix, encoding)
    else:
        raise ValueError('fastText: model name is not valid!')
